# -*- coding:utf-8; -*-
#+TITLE: Unit Tests & Examples for Orgtbl Aggregate
Copyright (C) 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022  Thierry Banel

org-aggregate is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

org-aggregate is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

* How to run?
** Running tests should leave the file unchanged
Running all the tests should not change anything to this
page. Therefore the suggested workflow is:
- make a temporary copy of this file, then on this copy:
- optionaly clean the computed tables
- run all pull-mode tests
- run all push-mode test
- compare the copy and the original, there should be no difference
  (=M-x compare-windows= is handy)

** Old resulting tables can be cleaned prior to running tests
this is optional
#+begin_src elisp :results none
(save-excursion
  (goto-char (point-min))
  (replace-regexp
   (rx (group bol "#+BEGIN" (* not-newline) "\n")
       (* "|" (* not-newline) "\n"))
   "\\1"))
#+end_src

** All pull-mode tests can be re-computed at once by executing:
#+begin_src elisp :results none
(let ((org-calc-default-modes
       (cons 'calc-float-format (cons '(float 12) org-calc-default-modes))))
  (org-update-all-dblocks))
#+end_src

** All push-mode tests can be re-computed at once by executing:
#+begin_src elisp :results none
(let ((org-calc-default-modes
       (cons 'calc-float-format (cons '(float 12) org-calc-default-modes))))
  (org-table-map-tables
    (lambda ()
      (when (save-excursion
	      (forward-line -1)
	      (looking-at-p (rx (or "#+begin" "#+orgtbl"))))
	(orgtbl-send-table 'maybe)))))
#+end_src

* Test PUSH
Push = source table drives computation of aggregated tables.
Run by typing C-c C-c on the first pipe of the source table.

** Source table
No need to name it.

#+ORGTBL: SEND aggtable1 orgtbl-to-aggregated-table :cols "sum($3) $2 sum($4) mean($5) $3*$3 min($5) max($5)"
#+ORGTBL: SEND aggtable2 orgtbl-to-aggregated-table :cols "sum(x) q sum(y) mean(z) x*x min(z) max(z)"
#+ORGTBL: SEND aggtable3 orgtbl-to-aggregated-table :cols "p count() sum($4) mean(z) sum(z*z) (x) min(y) max(y)"
#+ORGTBL: SEND aggtable4 orgtbl-to-aggregated-table :cols "count() mean(x) mean(y) mean(z) meane(z) median(z)" :cond (not (equal f ""))
#+ORGTBL: SEND aggtable5 orgtbl-to-aggregated-table :cols "count() mean(x) mean(y) mean(z) meane(z) median(z) hline"
#+ORGTBL: SEND aggtable6 orgtbl-to-aggregated-table :cols "q prod(z) sdev(z) pvar(z) psdev(z)"
#+ORGTBL: SEND aggtable7 orgtbl-to-aggregated-table :cols "q prod(z) cov(x,y) corr(z,z)"
#+ORGTBL: SEND aggtable8 orgtbl-to-aggregated-table :cols "hline min(d) max(d) mean(d)"
#+ORGTBL: SEND aggtable9 orgtbl-to-aggregated-table :cols "sum(x) q sum(y) mean(z) x*x min(z) max(z)" :cond (equal hline "2")
#+ORGTBL: SEND aggtablea orgtbl-to-aggregated-table :cols "sum(x) q sum(y) mean(z) x*x min(z) max(z)" :cond (equal q "b")
| p | q |   x |    y | z | f | d                      |
|---+---+-----+------+---+---+------------------------|
| 1 | b |  12 |    8 | 9 | 0 | [2013-12-22 sun 09:01] |
| 3 | b |  12 |    8 | 9 | 0 | [2013-11-23 sat 13:04] |
| 1 | a |   3 |    2 | 4 | 0 | [2011-09-24 sat 13:54] |
| 2 | a |   3 |    2 | 2 |   | [2013-09-25 wed 03:54] |
| 3 | a |   3 |    2 | 1 |   | [2014-02-26 wed 16:11] |
| 3 | a |   5 |    4 | 2 |   | [2014-01-18 sat 03:51] |
| 1 | a | 5.1 |    2 | 8 | 1 | [2013-12-25 wed 00:00] |
|---+---+-----+------+---+---+------------------------|
| 2 | b |   9 |    8 | 5 |   | [2012-12-25 tue 00:00] |
| 3 | b |   9 |    8 | 1 |   | [2014-01-18 sat 23:22] |
| 4 | a |   a |    a | 8 |   | [2014-08-02 sat 23:22] |
| 5 | a |   a | 10*a | 4 |   | [2015-09-14 mon 13:07] |
|---+---+-----+------+---+---+------------------------|
| 4 | b |   b |    b | 6 | 1 | [2015-10-02 fri 17:42] |
| 5 | b | b+3 |  b*b | 8 | 1 | [2016-01-28 thu 15:06] |

** Resulting tables

#+BEGIN RECEIVE ORGTBL aggtable1
| sum($3)    | $2 | sum($4)      |      mean($5) | $3*$3             | min($5) | max($5) |
|------------+----+--------------+---------------+-------------------+---------+---------|
| 2 b + 45   | b  | b + b^2 + 32 | 6.33333333333 | 2 b^2 + 6 b + 459 |       1 |       9 |
| 2 a + 19.1 | a  | 11 a + 12    | 4.14285714286 | 2 a^2 + 78.01     |       1 |       8 |
#+END RECEIVE ORGTBL aggtable1

#+BEGIN RECEIVE ORGTBL aggtable2
| sum(x)     | q | sum(y)       |       mean(z) | x*x               | min(z) | max(z) |
|------------+---+--------------+---------------+-------------------+--------+--------|
| 2 b + 45   | b | b + b^2 + 32 | 6.33333333333 | 2 b^2 + 6 b + 459 |      1 |      9 |
| 2 a + 19.1 | a | 11 a + 12    | 4.14285714286 | 2 a^2 + 78.01     |      1 |      8 |
#+END RECEIVE ORGTBL aggtable2

#+BEGIN RECEIVE ORGTBL aggtable3
| p | count() |    sum($4) | mean(z) | sum(z*z) | (x)           |         min(y) |         max(y) |
|---+---------+------------+---------+----------+---------------+----------------+----------------|
| 1 |       3 |         12 |       7 |      161 | [12, 3, 5.1]  |              2 |              8 |
| 3 |       4 |         22 |    3.25 |       87 | [12, 3, 5, 9] |              2 |              8 |
| 2 |       2 |         10 |     3.5 |       29 | [3, 9]        |              2 |              8 |
| 4 |       2 |      a + b |       7 |      100 | [a, b]        |      min(a, b) |      max(a, b) |
| 5 |       2 | 10 a + b^2 |       6 |       80 | [a, b + 3]    | min(10 a, b^2) | max(10 a, b^2) |
#+END RECEIVE ORGTBL aggtable3

#+BEGIN RECEIVE ORGTBL aggtable4
| count() | mean(x)                 | mean(y)                         |       mean(z) | meane(z)                         | median(z) |
|---------+-------------------------+---------------------------------+---------------+----------------------------------+-----------|
|       6 | 0.333333333333 b + 5.85 | b / 6 + b^2 / 6 + 3.33333333333 | 7.33333333333 | 7.33333333333 +/- 0.802772971919 |         8 |
#+END RECEIVE ORGTBL aggtable4

#+BEGIN RECEIVE ORGTBL aggtable5
| count() | mean(x)       | mean(y)         | mean(z) | meane(z)              | median(z) | hline |
|---------+---------------+-----------------+---------+-----------------------+-----------+-------|
|       7 | 6.15714285714 | 4               |       5 | 5 +/- 1.34518541827   |         4 |     0 |
|       4 | 0.5 a + 4.5   | 2.75 a + 4      |     4.5 | 4.5 +/- 1.44337567297 |       4.5 |     1 |
|       2 | b + 1.5       | b / 2 + b^2 / 2 |       7 | 7 +/- 1               |         7 |     2 |
#+END RECEIVE ORGTBL aggtable5

#+BEGIN RECEIVE ORGTBL aggtable6
| q | prod(z) |       sdev(z) |       pvar(z) |      psdev(z) |
|---+---------+---------------+---------------+---------------|
| b |   19440 | 3.07679486912 | 7.88888888889 | 2.80871659106 |
| a |    4096 | 2.85356919364 | 6.97959183673 | 2.64189171556 |
#+END RECEIVE ORGTBL aggtable6

#+BEGIN RECEIVE ORGTBL aggtable7
| q | prod(z) | cov(x,y)                                                         | corr(z,z) |
|---+---------+------------------------------------------------------------------+-----------|
| b |   19440 | 0.133333333333 b^3 - 3.63333333333 b - 0.766666666667 b^2 + 19.2 |        1. |
| a |    4096 | 1.30952380953 a^2 - 5.57380952381 a + 2.5761904762               |        1. |
#+END RECEIVE ORGTBL aggtable7

#+BEGIN RECEIVE ORGTBL aggtable8
| hline | min(d)                 | max(d)                 |                     mean(d) |
|-------+------------------------+------------------------+-----------------------------|
|     0 | <2011-09-24 Sat 13:54> | <2014-02-26 Wed 16:11> | <14089-07-11 Mon 11:55> / 7 |
|     1 | <2012-12-25 Tue 00:00> | <2015-09-14 Mon 13:07> |               735354.373438 |
|     2 | <2015-10-02 Fri 17:42> | <2016-01-28 Thu 15:06> |               735932.683334 |
#+END RECEIVE ORGTBL aggtable8

#+BEGIN RECEIVE ORGTBL aggtable9
| sum(x)  | q | sum(y)  | mean(z) | x*x             | min(z) | max(z) |
|---------+---+---------+---------+-----------------+--------+--------|
| 2 b + 3 | b | b + b^2 |       7 | 2 b^2 + 6 b + 9 |      6 |      8 |
#+END RECEIVE ORGTBL aggtable9

#+BEGIN RECEIVE ORGTBL aggtablea
| sum(x)   | q | sum(y)       |       mean(z) | x*x               | min(z) | max(z) |
|----------+---+--------------+---------------+-------------------+--------+--------|
| 2 b + 45 | b | b + b^2 + 32 | 6.33333333333 | 2 b^2 + 6 b + 459 |      1 |      9 |
#+END RECEIVE ORGTBL aggtablea

* Test PULL
Pull = aggregated table knows how to compute itself,
       source table is unaware of the aggregation.

** Source table
Not changed in any way by the aggregate process.
(Note: non-ascii characters are used as column names)

#+TBLNAME: pulledtable
| pé | qû |  xà |   yÿ | zö | déf |
|----+----+-----+------+----+-----|
|  1 | b  |  12 |    8 |  9 |     |
|  3 | b  |  12 |    8 |  9 |     |
|  1 | a  |   3 |    2 |  4 |   1 |
|  2 | a  |   3 |    2 |  2 |     |
|  3 | a  |   3 |    2 |  1 |   1 |
|  3 | a  |   5 |    4 |  2 |   1 |
|  1 | a  | 5.1 |    2 |  8 |   1 |
|  2 | b  |   9 |    8 |  5 |     |
|  3 | b  |   9 |    8 |  1 |     |
|  4 | a  |   a |    a |  8 |     |
|  5 | a  |   a | 10*a |  4 |   1 |
|  4 | b  |   b |    b |  6 |   1 |
|  5 | b  | b+3 |  b*b |  8 |     |

** Resulting tables
Type C-c C-c within each to refresh

Note the =:formula= parameter to add a new column after the aggregation has been computed.

#+BEGIN: aggregate :table pulledtable :cols ("qû" "mean(zö)") :formula "$3=$2*100"
| qû |      mean(zö) |           |
|----+---------------+-----------|
| b  | 6.33333333333 | 633.33333 |
| a  | 4.14285714286 | 414.28571 |
#+TBLFM: $3=$2*100
#+END

Note the additional =$8= column automatically computed after the aggregation

#+BEGIN: aggregate :table pulledtable :cols "sum(xà) qû sum(yÿ) mean(zö) xà*xà min(zö) max(zö)"
| sum(xà)    | qû | sum(yÿ)      |      mean(zö) | xà*xà             | min(zö) | max(zö) |     |
|------------+----+--------------+---------------+-------------------+---------+---------+-----|
| 2 b + 45   | b  | b + b^2 + 32 | 6.33333333333 | 2 b^2 + 6 b + 459 |       1 |       9 |   5 |
| 2 a + 19.1 | a  | 11 a + 12    | 4.14285714286 | 2 a^2 + 78.01     |       1 |       8 | 4.5 |
#+TBLFM: $8=($6+$7)/2
#+END

#+BEGIN: aggregate :table pulledtable :cols "pé count() sum($4) mean(zö) sum(zö*zö) (xà) min(yÿ) max(yÿ)"
| pé | count() |    sum($4) | mean(zö) | sum(zö*zö) | (xà)          |        min(yÿ) |        max(yÿ) |
|----+---------+------------+----------+------------+---------------+----------------+----------------|
|  1 |       3 |         12 |        7 |        161 | [12, 3, 5.1]  |              2 |              8 |
|  3 |       4 |         22 |     3.25 |         87 | [12, 3, 5, 9] |              2 |              8 |
|  2 |       2 |         10 |      3.5 |         29 | [3, 9]        |              2 |              8 |
|  4 |       2 |      a + b |        7 |        100 | [a, b]        |      min(a, b) |      max(a, b) |
|  5 |       2 | 10 a + b^2 |        6 |         80 | [a, b + 3]    | min(10 a, b^2) | max(10 a, b^2) |
#+END

#+BEGIN: aggregate :table pulledtable :cols "count() mean(xà) mean(yÿ) mean(zö)"
| count() | mean(xà)                                            | mean(yÿ)                                             |      mean(zö) |
|---------+-----------------------------------------------------+------------------------------------------------------+---------------|
|      13 | 0.153846153846 a + 0.153846153846 b + 4.93076923077 | 0.846153846154 a + b / 13 + b^2 / 13 + 3.38461538462 | 5.15384615385 |
#+END

#+BEGIN: aggregate :table pulledtable :cols "pé count() mean(zö) meane(zö) gmean(zö) hmean(zö) median(zö)"
| pé | count() | mean(zö) | meane(zö)              |     gmean(zö) |     hmean(zö) | median(zö) |
|----+---------+----------+------------------------+---------------+---------------+------------|
|  1 |       3 |        7 | 7 +/- 1.52752523165    | 6.60385449779 | 6.17142857143 |          8 |
|  3 |       4 |     3.25 | 3.25 +/- 1.93110503771 | 2.05976714391 | 1.53191489362 |        1.5 |
|  2 |       2 |      3.5 | 3.5 +/- 1.5            | 3.16227766017 | 2.85714285714 |        3.5 |
|  4 |       2 |        7 | 7 +/- 1                | 6.92820323028 | 6.85714285714 |          7 |
|  5 |       2 |        6 | 6 +/- 2                | 5.65685424949 | 5.33333333333 |          6 |
#+END

#+BEGIN: aggregate :table pulledtable :cols "qû count() prod(zö) sdev(zö) pvar(zö) psdev(zö)"
| qû | count() | prod(zö) |      sdev(zö) |      pvar(zö) |     psdev(zö) |
|----+---------+----------+---------------+---------------+---------------|
| b  |       6 |    19440 | 3.07679486912 | 7.88888888889 | 2.80871659106 |
| a  |       7 |     4096 | 2.85356919364 | 6.97959183673 | 2.64189171556 |
#+END

#+BEGIN: aggregate :table pulledtable :cols "qû count() cov(zö,xà) pcov(zö,zö) corr(zö,zö)"
| qû | count() | cov(zö,xà)                       |   pcov(zö,zö) | corr(zö,zö) |
|----+---------+----------------------------------+---------------+-------------|
| b  |       6 | 0.266666666666 b + 1.8           | 7.88888888889 |          1. |
| a  |       7 | 0.619047619047 a - 1.22142857142 | 6.97959183673 |          1. |
#+END

* Test :cond PUSH

** Source table
Only the second group (5 rows) is considered with the test =hline=1=.

#+ORGTBL: SEND aggtable15 orgtbl-to-aggregated-table :cond (equal hline "1") :cols "count() q mean(x) mean(y) mean(z) hline"
| p | q |   x |    y | z |
|---+---+-----+------+---|
| 1 | b |  12 |    8 | 9 |
| 3 | b |  12 |    8 | 9 |
| 1 | a |   3 |    2 | 4 |
| 2 | a |   3 |    2 | 2 |
| 3 | a |   3 |    2 | 1 |
| 3 | a |   5 |    4 | 2 |
| 1 | a | 5.1 |    2 | 8 |
|---+---+-----+------+---|
| 2 | b |   9 |    8 | 5 |
| 3 | b |   9 |    8 | 1 |
| 4 | a |   a |    a | 8 |
| 5 | a |   a | 10*a | 4 |
| 4 | b |   b |    b | 6 |
|---+---+-----+------+---|
| 5 | b | b+3 |  b*b | 8 |

** Aggregated table

#+BEGIN RECEIVE ORGTBL aggtable15
| count() | q | mean(x)   | mean(y)               | mean(z) | hline |
|---------+---+-----------+-----------------------+---------+-------|
|       3 | b | b / 3 + 6 | b / 3 + 5.33333333333 |       4 |     1 |
|       2 | a | a         | 5.5 a                 |       6 |     1 |
#+END RECEIVE ORGTBL aggtable15

* Test :cond PULL
The =:cond= parameter takes a lisp expression
to filter-out resulting rows.

** Resulting tables
Only consider rows for which column q have the value "b"

#+BEGIN: aggregate :table pulledtable :cols "qû count() mean(zö)" :cond (equal qû "b")
| qû | count() |      mean(zö) |
|----+---------+---------------|
| b  |       6 | 6.33333333333 |
#+END

Only consider rows for which column =p= is greater than =3=.
Note the =string-to-number= call, because cells always contain strings.

#+BEGIN: aggregate :table pulledtable :cols "qû count() mean(zö)" :cond (>= (string-to-number pé) 3)
| qû | count() | mean(zö) |
|----+---------+----------|
| b  |       4 |        6 |
| a  |       4 |     3.75 |
#+END

Only consider rows for which the =def= column is not blank.

#+BEGIN: aggregate :table pulledtable :cols "qû count() mean(zö) déf" :cond (not (equal déf ""))
| qû | count() | mean(zö) | déf |
|----+---------+----------+-----|
| a  |       5 |      3.8 |   1 |
| b  |       1 |        6 |   1 |
#+END

* Test correlation
Are two columns correlated ?

** Source table
Contains columns correlated with some noise.
: y = 10* + noise             (x y are highly correlated)
: z = pure noise              (x z are not correlated)
: t = pure noise              (z t are not correlated)
: m = 10*x in reverse order   (x m are negative correlated)

#+TBLNAME: correlated
| tag   |  x |       y |     z |     t |   m |
|-------+----+---------+-------+-------+-----|
| small |  1 |  10.414 | 78.30 |  1.70 | 120 |
| small |  2 |  20.616 | 48.20 | 80.40 | 110 |
| small |  3 |  30.210 | 93.50 | 25.10 | 100 |
| small |  4 |  41.692 | 85.90 | 16.30 |  90 |
| small |  5 |  50.576 | 11.70 | 37.00 |  80 |
| large |  6 |  60.026 | 46.60 |  6.00 |  70 |
| large |  7 |  71.236 |  3.30 | 35.70 |  60 |
| large |  8 |  81.204 | 78.80 | 46.30 |  50 |
| large |  9 |  90.862 | 89.60 | 98.40 |  40 |
| large | 10 | 101.240 |  0.60 |  8.80 |  30 |
| large | 11 | 111.924 | 32.40 | 63.70 |  20 |
| large | 12 | 120.490 | 35.50 | 98.20 |  10 |

The following line was appended to the table to generate the random noise.
It is thrown away to avoid recomputing new noise, and thus invalidating the test.
: #+TBLFM: $3=$2*10+random(1000)/500;%.3f::$4=random(1000)/10;%.2f::$5=random(1000)/10;%.2f

** Resulting table
Type C-c C-c within resulting table to refresh.

#+BEGIN: aggregate :table correlated :cols "tag corr(x,y) corr(x,z) corr(x,m) corr(z,t)"
| tag   |      corr(x,y) |       corr(x,z) | corr(x,m) |      corr(z,t) |
|-------+----------------+-----------------+-----------+----------------|
| small | 0.999449791325 | -0.448296141593 |        -1 | -0.49786310458 |
| large | 0.999657841285 | -0.120566390616 |        -1 | 0.486014333463 |
#+END

* Test without headers
What if the source table does not have headers?
Then columns should be named =$1=, =$2=, =$3= and so on.

** Source table

#+TBLNAME: noheader
| 0 | z |   t |    x | y |
| 1 | b |  12 |    8 | 9 |
| 3 | b |  12 |    8 | 9 |
| 1 | a |   3 |    2 | 4 |
| 2 | a |   3 |    2 | 2 |
| 3 | a |   3 |    2 | 1 |
| 3 | a |   5 |    4 | 2 |
| 1 | a | 5.1 |    2 | 8 |
| 2 | b |   9 |    8 | 5 |
| 3 | b |   9 |    8 | 1 |
| 4 | a |   a |    a | 8 |
| 5 | a |   a | 10*a | 4 |
| 4 | b |   b |    b | 6 |
| 5 | b | b+3 |  b*b | 8 |

** Aggregated table

#+BEGIN: aggregate :table noheader :cols "hline $1 mean($3) sum($4)"
| hline | $1 | mean($3)            | sum($4)    |
|-------+----+---------------------+------------|
|     0 |  0 | t                   | x          |
|     0 |  1 | 6.7                 | 12         |
|     0 |  3 | 7.25                | 22         |
|     0 |  2 | 6                   | 10         |
|     0 |  4 | a / 2 + b / 2       | a + b      |
|     0 |  5 | a / 2 + b / 2 + 1.5 | 10 a + b^2 |
#+END

* Test hline grouping
Horizontal lines naturally create groups withing the source table.
Those groups can be accessed through the =hline= virtual column.

** Source table
It contains four groups separated by horizontal lines.

#+TBLNAME: hlinetable
| p | q |   x |    y | z | f |
|---+---+-----+------+---+---|
| 1 | b |  12 |    8 | 9 | 0 |
| 3 | b |  12 |    8 | 9 | 0 |
| 1 | a |   3 |    2 | 4 | 0 |
| 2 | a |   3 |    2 | 2 | 0 |
| 3 | a |   3 |    2 | 1 | 0 |
|---+---+-----+------+---+---|
| 3 | a |   5 |    4 | 2 | 1 |
| 1 | a | 5.1 |    2 | 8 | 1 |
|---+---+-----+------+---+---|
| 2 | b |   9 |    8 | 5 | 1 |
| 3 | b |   9 |    8 | 1 | 1 |
| 4 | a |   a |    a | 8 | 1 |
|---+---+-----+------+---+---|
| 5 | a |   a | 10*a | 4 | 1 |
| 4 | b |   b |    b | 6 | 1 |
| 5 | b | b+3 |  b*b | 8 | 1 |

** Aggregated table
The =hline= column groups data

#+BEGIN: aggregate :table hlinetable :cols "q hline vcount()" :cond (equal f "1")
| q | hline | vcount() |
|---+-------+----------|
| a |     1 |        2 |
| b |     2 |        2 |
| a |     2 |        1 |
| a |     3 |        1 |
| b |     3 |        2 |
#+END

* Test dates [YYYY-MM-DD day. HH:MM] style
Some (limited) handling of dates is available.

** Source table
#+tblname: datetable
| n | d                       |
|---+-------------------------|
| 1 | [2013-12-22 dim. 09:01] |
| 2 | [2013-11-23 sam. 13:04] |
| 3 | [2011-09-24 sam. 13:54] |
| 4 | [2013-09-25 mer. 03:54] |
| 5 | [2014-02-26 mer. 16:11] |
| 6 | [2014-01-18 sam. 03:51] |
| 7 | [2013-12-25 mer. 00:00] |
| 8 | [2012-12-25 mar. 00:00] |

** Aggregated table

#+BEGIN: aggregate :table datetable :cols "min(d) max(d) min(n) max(n) mean(d)"
| min(d)                 | max(d)                 | min(n) | max(n) |       mean(d) |
|------------------------+------------------------+--------+--------+---------------|
| <2011-09-24 Sat 13:54> | <2014-02-26 Wed 16:11> |      1 |      8 | 735073.937066 |
#+END

* Test durations HH:MM:SS style

** Source table
#+name: some_durations
|      dur |
|----------|
| 07:45:30 |
|    13:55 |
|    17:12 |

** Aggregated table

Test T, U, t formatters

#+BEGIN: aggregate :table "some_durations" :cols "vmean(dur) vmean(dur);T vmean(dur);t vmean(dur);U"
| vmean(dur) | vmean(dur) | vmean(dur) | vmean(dur) |
|------------+------------+------------+------------|
|      46650 |   12:57:30 |      12.96 |      12:57 |
#+END:

* Test durations HH@ MM' SS" style

#+name: calc_durations
| dur        |
|------------|
| 07@ 45' 30 |
| 13@ 55'    |
| 17@ 12'    |

#+BEGIN: aggregate :table "calc_durations" :cols "vmean(dur)"
| vmean(dur)   |
|--------------|
| 12@ 57' 30." |
#+END:

* Test symbolic
The Emacs Calc symbolic calculator is used by the aggregate package.
Therefore, symbolic calculations are available.

** Source table
Contains the variables =x= and =a=, which are not numeric.

#+TBLNAME: symtable
| Day       | Color |  Level | Quantity |
|-----------+-------+--------+----------|
| Monday    | Red   |   30+x |     11+a |
| Monday    | Blue  | 25+3*x |        3 |
| Thuesday  | Red   | 51+2*x |       12 |
| Thuesday  | Red   |   45-x |       15 |
| Thuesday  | Blue  |     33 |       18 |
| Wednesday | Red   |     27 |       23 |
| Wednesday | Blue  |   12+x |       16 |
| Wednesday | Blue  |     15 |   15-6*a |
| Turdsday  | Red   |     39 |   24-5*a |
| Turdsday  | Red   |     41 |       29 |
| Turdsday  | Red   |   49+x |   30+9*a |
| Friday    | Blue  |      7 |      5+a |
| Friday    | Blue  |      6 |        8 |
| Friday    | Blue  |     11 |        9 |

** Aggregated table
Result is variabilized with =x= and =a=.

#+BEGIN: aggregate :table "symtable" :cols "Day mean(Level) sum(Quantity)"
| Day       | mean(Level) | sum(Quantity) |
|-----------+-------------+---------------|
| Monday    | 2 x + 27.5  | a + 14        |
| Thuesday  | x / 3 + 43  | 45            |
| Wednesday | x / 3 + 18  | 54 - 6 a      |
| Turdsday  | x / 3 + 43. | 4 a + 83      |
| Friday    | 8           | a + 22        |
#+END

* Test zero output
The following test produces sums which happen to be zero, either
because input is empty, or by chance (1-1 = 0).
Zeros are no longer translated to empty cells.

#+TBLNAME: resultzero
| Item | Value |
|------+-------|
| a2   |     1 |
| a2   |     1 |
| a0   |    -1 |
| a0   |     1 |
| b2   |     2 |
| b2   |       |
| b0   |     0 |
| b0   |       |
| c    |       |
| c    |       |

#+BEGIN: aggregate :table resultzero :cols "Item vsum(Value) vmean(Value)"
| Item | vsum(Value) | vmean(Value) |
|------+-------------+--------------|
| a2   |           2 |            1 |
| a0   |           0 |            0 |
| b2   |           2 |            2 |
| b0   |           0 |            0 |
| c    |           0 |    vmean([]) |
#+END

* Test empty inputs
Empty input cells are most often ignored.
- This makes no difference for =sum= and =count=.
- For =prod=, empty input do not result in zero.
- For =mean=, only non-empty cells participate
  (if empty cells were zero, they would count in the division).
- For =min= and =max=, a possibly empty list of values is possible,
  resulting in =inf= or =-inf=

Some aggregation functions operate on two columns.
In this case, a pair of empty cells is ignored.
But a pair of an empty and a non-empty cell is
added to the aggregation, by replacing the missing
value with zero.

#+tblname: emptyinput
| T                |  Q |   R |
|------------------+----+-----|
| no-blank         |  1 |  10 |
| no-blank         |  2 |  20 |
| no-blank         |  3 |  30 |
| 1-left-blank     |  4 |  40 |
| 1-left-blank     |    |  50 |
| 1-left-blank     |  6 |  60 |
| 1-left-blank     |  7 |  70 |
| all-blank        |    |     |
| all-blank        |    |     |
| all-blank        |    |     |
| 2-left-blank     | 11 | 110 |
| 2-left-blank     | 12 | 120 |
| 2-left-blank     | 13 | 130 |
| 2-left-blank     | 14 | 140 |
| 1-dual-blank     | 15 | 150 |
| 1-dual-blank     |    |     |
| 1-dual-blank     | 17 | 170 |
| single-non-blank | 18 | 180 |
| single-non-blank |    |     |
| single-non-blank |    |     |

#+BEGIN: aggregate :table "emptyinput" :cols "T sum(Q) prod(Q) (Q) min(Q) max(Q)"
| T                | sum(Q) | prod(Q) | (Q)              | min(Q) | max(Q) |
|------------------+--------+---------+------------------+--------+--------|
| no-blank         |      6 |       6 | [1, 2, 3]        |      1 |      3 |
| 1-left-blank     |     17 |     168 | [4, 6, 7]        |      4 |      7 |
| all-blank        |      0 |       1 | []               |    inf |   -inf |
| 2-left-blank     |     50 |   24024 | [11, 12, 13, 14] |     11 |     14 |
| 1-dual-blank     |     32 |     255 | [15, 17]         |     15 |     17 |
| single-non-blank |     18 |      18 | [18]             |     18 |     18 |
#+END:

#+BEGIN: aggregate :table "emptyinput" :cols "T mean(Q) meane(Q) gmean(Q) hmean(Q)"
| T                |       mean(Q) | meane(Q)                         |      gmean(Q) |      hmean(Q) |
|------------------+---------------+----------------------------------+---------------+---------------|
| no-blank         |             2 | 2 +/- 0.577350269189             | 1.81712059283 | 1.63636363636 |
| 1-left-blank     | 5.66666666667 | 5.66666666667 +/- 0.881917103688 | 5.51784835276 | 5.36170212766 |
| all-blank        |     vmean([]) | vmeane([])                       |    vgmean([]) |    vhmean([]) |
| 2-left-blank     |          12.5 | 12.5 +/- 0.645497224368          | 12.4497700445 |  12.399483871 |
| 1-dual-blank     |            16 | 16 +/- 1                         | 15.9687194227 |       15.9375 |
| single-non-blank |            18 | vmeane([18])                     |            18 |           18. |
#+END:

#+BEGIN: aggregate :table "emptyinput" :cols "T min(Q) max(Q)"
| T                | min(Q) | max(Q) |
|------------------+--------+--------|
| no-blank         |      1 |      3 |
| 1-left-blank     |      4 |      7 |
| all-blank        |    inf |   -inf |
| 2-left-blank     |     11 |     14 |
| 1-dual-blank     |     15 |     17 |
| single-non-blank |     18 |     18 |
#+END:

#+BEGIN: aggregate :table "emptyinput" :cols "T pvar(Q) sdev(Q) psdev(Q)"
| T                |        pvar(Q) |       sdev(Q) |       psdev(Q) |
|------------------+----------------+---------------+----------------|
| no-blank         | 0.666666666667 |             1 | 0.816496580928 |
| 1-left-blank     |  1.55555555556 | 1.52752523165 |  1.24721912893 |
| all-blank        |      vpvar([]) |     vsdev([]) |     vpsdev([]) |
| 2-left-blank     |           1.25 | 1.29099444874 |  1.11803398875 |
| 1-dual-blank     |              1 | 1.41421356237 |              1 |
| single-non-blank |              0 |   vsdev([18]) |              0 |
#+END:

#+BEGIN: aggregate :table "emptyinput" :cols "T corr(Q,R);EN cov(Q,R);EN pcov(Q,R);EN"
| T                |                   corr(Q,R) |      cov(Q,R) |     pcov(Q,R) |
|------------------+-----------------------------+---------------+---------------|
| no-blank         |                           1 |            10 | 6.66666666667 |
| 1-left-blank     |              0.625543242171 |           25. |         18.75 |
| all-blank        | vcorr([0, 0, 0], [0, 0, 0]) |             0 |             0 |
| 2-left-blank     |                          1. | 16.6666666667 |          12.5 |
| 1-dual-blank     |                          1. | 863.333333333 | 575.555555556 |
| single-non-blank |                           1 |          1080 |           720 |
#+END:

#+BEGIN: aggregate :table "emptyinput" :cols "T count() (Q) (R)"
| T                | count() | (Q)              | (R)                  |
|------------------+---------+------------------+----------------------|
| no-blank         |       3 | [1, 2, 3]        | [10, 20, 30]         |
| 1-left-blank     |       4 | [4, 6, 7]        | [40, 50, 60, 70]     |
| all-blank        |       3 | []               | []                   |
| 2-left-blank     |       4 | [11, 12, 13, 14] | [110, 120, 130, 140] |
| 1-dual-blank     |       3 | [15, 17]         | [150, 170]           |
| single-non-blank |       3 | [18]             | [180]                |
#+END:

* Test empty and non-numeric

#+tblname: nonnumeric
|  X |
|----|
|  1 |
|  2 |
| aa |
|    |
|  4 |

#+BEGIN: aggregate :table "nonnumeric" :cols "(X) (X);E (X);N (X);EN"
| (X)           | (X)                | (X)          | (X)             |
|---------------+--------------------+--------------+-----------------|
| [1, 2, aa, 4] | [1, 2, aa, nan, 4] | [1, 2, 0, 4] | [1, 2, 0, 0, 4] |
#+END:

#+BEGIN: aggregate :table "nonnumeric" :cols "mean(X) mean(X);E mean(X);N mean(X);EN"
| mean(X)       | mean(X) | mean(X) | mean(X) |
|---------------+---------+---------+---------|
| aa / 4 + 1.75 |     nan |    1.75 |     1.4 |
#+END:

Comparison with the spreadsheet:

| 1                  |                 1 |
| 2                  |                 2 |
| aa                 |                aa |
|                    |                   |
| 4                  |                 4 |
|--------------------+-------------------|
| [1, 2, aa, 4]      | 0.75 + aa / 4 + 1 |
| [1, 2, aa, nan, 4] |               nan |
| [1, 2, 0, 4]       |              1.75 |
| [1, 2, 0, 0, 4]    |               1.4 |
#+TBLFM: @6$1=@1..@5 :: @7$1=@1..@5;E :: @8$1=@1..@5;N :: @9$1=@1..@5;EN :: @6$2=vmean(@1..@5) :: @7$2=vmean(@1..@5);E :: @8$2=vmean(@1..@5);N :: @9$2=vmean(@1..@5);EN

* Test input errors

#+tblname: inputerrors
| A |  Q |     R |         Z | D            |
|---+----+-------+-----------+--------------|
| a |  3 |    10 | 2.3025851 | [2014-11-05] |
| a | 4+ |    20 | 2.9957323 | [2014-11-21] |
| b |  t | (88*) |    #ERROR | [2014-12-07] |
| b |  1 |    41 | 3.7135721 | [2014-12-23] |
| b |  2 |   111 | 4.7095302 | [2015-01-08] |
| c |  8 |   z ' |    #ERROR |              |
| c | 4= |     4 | 1.3862944 |              |
#+TBLFM: $4=log($3)

#+BEGIN: aggregate :table "inputerrors" :cols "A sum(Q) sum(R)"
| A | sum(Q)                             | sum(R)                               |
|---+------------------------------------+--------------------------------------|
| a | error(2, '"Expected a number") + 3 | 30                                   |
| b | t + 3                              | error(4, '"Expected a number") + 152 |
| c | error(2, '"Expected a number") + 8 | error(2, '"Syntax error") + 4        |
#+END:

#+BEGIN: aggregate :table "inputerrors" :cols "A (Q) (R)"
| A | (Q)                                 | (R)                                       |
|---+-------------------------------------+-------------------------------------------|
| a | [3, error(2, '"Expected a number")] | [10, 20]                                  |
| b | [t, 1, 2]                           | [error(4, '"Expected a number"), 41, 111] |
| c | [8, error(2, '"Expected a number")] | [error(2, '"Syntax error"), 4]            |
#+END:

* Test modifiers

#+tblname: bigprec
| A  | Q     |                   N |
|----+-------+---------------------|
| a  | 12    |                  20 |
| a  | t+1   |   3.000000000000007 |
| bb | 77    |                   4 |
| bb | 2*t   | 5.12345678987654321 |
| bb | 2*t+1 |                   6 |

#+BEGIN: aggregate :table "bigprec" :cols "A sum(Q) mean(Q);FS (Q)"
| A  | sum(Q)   | mean(Q)      | (Q)                |
|----+----------+--------------+--------------------|
| a  | t + 13   | t / 2 + 13:2 | [12, t + 1]        |
| bb | 4 t + 78 | 4:3 t + 26   | [77, 2 t, 2 t + 1] |
#+END:

#+BEGIN: aggregate :table "bigprec" :cols "A sum(N);p20f18 sum(N);%.5f mean(N);f15 (N);f3"
| A  |                sum(N) |   sum(N) |            mean(N) | (N)           |
|----+-----------------------+----------+--------------------+---------------|
| a  | 23.000000000000007000 | 23.00000 | 11.500000000000000 | [20, 3.000]   |
| bb | 15.123456789876543210 | 15.12346 |  5.041152263290000 | [4, 5.123, 6] |
#+END:
* Test chaining

Result of an aggregation can be further processed, for example with another aggregation.

** chaining 3 aggregations

#+TBLNAME: amx
| A | M | X |
|---+---+---|
| a | m | 1 |
| a | p | 2 |
| a | m | 3 |
|---+---+---|
| b | p | 4 |
| b | m | 5 |
| b | p | 6 |
| b | m | 7 |

#+TBLNAME: amsx
#+BEGIN: aggregate :table "amx" :cols "A M sum(X)"
| A | M | SX |
|---+---+----|
| a | m |  4 |
| a | p |  2 |
| b | p | 10 |
| b | m | 12 |
#+TBLFM: @1$3=SX
#+END:

#+TBLNAME: asx
#+BEGIN: aggregate :table "amsx" :cols "A sum(SX)"
| A | SSX |
|---+-----|
| a |   6 |
| b |  22 |
#+TBLFM: @1$2=SSX
#+END:

#+BEGIN: aggregate :table "asx" :cols "sum(SSX)"
| sum(SSX) |
|----------|
|       28 |
#+END:

** chaining 2 transpositions

#+TBLNAME: tamx
#+BEGIN: transpose :table "amx"
| A |   | a | a | a |   | b | b | b | b |
| M |   | m | p | m |   | p | m | p | m |
| X |   | 1 | 2 | 3 |   | 4 | 5 | 6 | 7 |
#+END:

#+BEGIN: transpose :table "tamx"
| A | M | X |
|---+---+---|
| a | m | 1 |
| a | p | 2 |
| a | m | 3 |
|---+---+---|
| b | p | 4 |
| b | m | 5 |
| b | p | 6 |
| b | m | 7 |
#+END:

The double transposition is identical to the original "amx" table,
including horizontal lines
* Test funny column names
Name of columns are not unnecessarily alphanumeric words.
They need to be single or double quoted in formulas.
In a :cond lisp formula, only double quotes work.

** Quoted names

#+NAME: funnynames
| first column | observed;number | computed/expected |
|--------------+-----------------+-------------------|
| a/experiment |             2.3 |               2.4 |
| a/experiment |            15.4 |              12.1 |
| a/experiment |             8.2 |               6.9 |
| b/test       |           -98.7 |               0.0 |
| b/test       |             4.5 |               3.4 |
| b/test       |             2.2 |               2.9 |
| zero         |               0 |                 0 |

#+BEGIN: aggregate :table "funnynames" :cols "\"first column\" mean('observed;number');%.3f mean('computed/expected');%.4f" :cond (and (>= (string-to-number "observed;number") 0) (not (equal "first column" "zero")))
| "first column" | mean('observed;number') | mean('computed/expected') |
|----------------+-------------------------+---------------------------|
| a/experiment   |                   8.633 |                    7.1333 |
| b/test         |                   3.350 |                    3.1500 |
#+END:

#+BEGIN: aggregate :table "funnynames" :cols ("'first column'" "mean('observed;number');%.3f" "mean('computed/expected');%.4f") :cond "(and (>= (string-to-number \"observed;number\") 0) (not (equal \"first column\" \"zero\")))"
| 'first column' | mean('observed;number') | mean('computed/expected') |
|----------------+-------------------------+---------------------------|
| a/experiment   |                   8.633 |                    7.1333 |
| b/test         |                   3.350 |                    3.1500 |
#+END:

#+BEGIN: transpose :table "funnynames" :cols ("first column" "computed/expected" "observed;number")
| first column      |   | a/experiment | a/experiment | a/experiment | b/test | b/test | b/test | zero |
| computed/expected |   |          2.4 |         12.1 |          6.9 |    0.0 |    3.4 |    2.9 |    0 |
| observed;number   |   |          2.3 |         15.4 |          8.2 |  -98.7 |    4.5 |    2.2 |    0 |
#+END:

#+BEGIN: transpose :table "funnynames" :cols "'first column' 'computed/expected' 'observed;number'"
| first column      |   | a/experiment | a/experiment | a/experiment | b/test | b/test | b/test | zero |
| computed/expected |   |          2.4 |         12.1 |          6.9 |    0.0 |    3.4 |    2.9 |    0 |
| observed;number   |   |          2.3 |         15.4 |          8.2 |  -98.7 |    4.5 |    2.2 |    0 |
#+END:

** Non alphanumeric names
Accepted column names which do not require quoting:
- ascii letters
- numbers
- underscore _, dollar $, dot .
- accented letters like à é
- greek letters like α, Ω
- northen letters like ø
- russian letters like й
- esperanto letters like ŭ

#+NAME: non_alphanum
| _key.$ | v_A$4lé.à.α | on.eüΩ.øйŭ | 3.14 |
|--------+-------------+------------+------|
| a      |         2.2 |          1 |   10 |
| a      |         4.9 |          1 |   11 |
| b      |         7.7 |          1 |   12 |
| b      |         2.8 |          0 |   13 |
| b      |         9.3 |          0 |   14 |
| c      |         6.5 |          0 |   15 |
| a      |         8.4 |          0 |   16 |
| a      |         1.9 |          0 |   17 |
| b      |         5.6 |          0 |   18 |
| c      |         7.2 |          0 |   19 |

#+BEGIN: aggregate :table "non_alphanum" :cols "_key.$ vsum(v_A$4lé.à.α) vsum(on.eüΩ.øйŭ*10) vlist(on.eüΩ.øйŭ) vmean(3.14*1000)"
| _key.$ | vsum(v_A$4lé.à.α) | vsum(on.eüΩ.øйŭ*10) | vlist(on.eüΩ.øйŭ) | vmean(3.14*1000) |
|--------+-------------------+---------------------+-------------------+------------------|
| a      |              17.4 |                  20 | 1, 1, 0, 0        |            13500 |
| b      |              25.4 |                  10 | 1, 0, 0, 0        |            14250 |
| c      |              13.7 |                   0 | 0, 0              |            17000 |
#+END:

* Test malformed tables
Some columns are missing in some rows
This is on purpose
orgaggregate should tolerate such tables
Missing cells are handled as though they were empty

#+NAME: malformed
| Color | Level | Quantity | Day       |
|-------+-------+----------+-----------|
| Red   |    30 |       11 | Monday    |
| Blue  |    25 |        3 | Monday    |
|
| Red   |    45 |       15 | Tuesday   |
| Blue  |    33 |       18 | Tuesday   |
| Red   |    27 |
| Blue  |    12 |       16 | Wednesday |
| Blue  |    15 |       15 |
| Red   |    39 |       24 | Thursday  |
| Red   |    41 |       29 | Thursday  |
| Red   |    49 |       30 | Thursday  |
| Blue  |     7 |        5 | Friday    |
| Blue  |     6 |
| Blue  |    11 |        9 | Friday    |

#+BEGIN: aggregate :table "malformed" :cols "Day count() sum(Quantity)"
| Day       | count() | sum(Quantity) |
|-----------+---------+---------------|
| Monday    |       2 |            14 |
|           |       4 |            15 |
| Tuesday   |       2 |            33 |
| Wednesday |       1 |            16 |
| Thursday  |       3 |            83 |
| Friday    |       2 |            14 |
#+END:
* Test vlist($) vs. ($)

#+name: suitableforlist
| Day       | Color      | Level |
|-----------+------------+-------|
| Monday    | Red        | 20*30 |
| Monday    | Blue       | 55+25 |
| Tuesday   | Red        |    51 |
| Tuesday   | Red        |    45 |
| Tuesday   | Blue       |    33 |
| Wednesday | Red        |    27 |
| Wednesday | Blue       |    12 |
| Wednesday | Green      |    15 |
| Thursday  | Red        |    39 |
| Thursday  | Red        |    41 |
| Thursday  | Red+Green  |    49 |
| Friday    | Blue       |   (7) |
| Friday    | Blue       | (6+1) |
| Friday    | Blue&Green |  [11] |

#+BEGIN: aggregate :table "suitableforlist" :cols "Day vlist(Color) (Color) vlist(Level) (Level) Level*100 Level^2"
| Day       | vlist(Color)           | (Color)                                 | vlist(Level)     | (Level)      | Level*100          | Level^2 |
|-----------+------------------------+-----------------------------------------+------------------+--------------+--------------------+---------|
| Monday    | Red, Blue              | [Red, Blue]                             | 20*30, 55+25     | [600, 80]    | [60000, 8000]      |  366400 |
| Tuesday   | Red, Red, Blue         | [Red, Red, Blue]                        | 51, 45, 33       | [51, 45, 33] | [5100, 4500, 3300] |    5715 |
| Wednesday | Red, Blue, Green       | [Red, Blue, Green]                      | 27, 12, 15       | [27, 12, 15] | [2700, 1200, 1500] |    1098 |
| Thursday  | Red, Red, Red+Green    | [Red, Red, Red + Green]                 | 39, 41, 49       | [39, 41, 49] | [3900, 4100, 4900] |    5603 |
| Friday    | Blue, Blue, Blue&Green | [Blue, Blue, error(4, '"Syntax error")] | (7), (6+1), [11] | [7, 7, [11]] | [700, 700, [1100]] |     219 |
#+END:

* Test sorting key alpha & numeric

#+NAME: unsortedtable
| p | q |    x | Day       | Color | Level | date                   |
|---+---+------+-----------+-------+-------+------------------------|
| 1 | b | 12.3 | Monday    | Red   |  2*30 | [2024-12-23 Mon 09:01] |
| 3 | b | 12.8 | Monday    | Blue  |  5+25 | [2019-11-24 Sun 13:04] |
| 1 | a |  3.5 | Tuesday   | Red   |    51 | [2029-09-25 Tue 13:54] |
| 2 | a |  3.9 | Tuesday   | Red   |    45 | [2033-09-26 Mon 03:55] |
| 3 | a |  3.5 | Tuesday   | Blue  |    33 | [2015-02-27 Fri 16:11] |
| 3 | a |  5.7 | Wednesday | Red   |    97 | [2001-01-19 Fri 03:49] |
| 1 | a |  5.1 | Wednesday | Blue  |    52 | [2035-12-26 Wed 00:00] |
|---+---+------+-----------+-------+-------+------------------------|
| 2 | b |  9.3 | Tuesday   | Red   |    39 | [2035-12-26 Wed 00:00] |
| 3 | b |  9.3 | Thursday  | Red   |    41 | [2002-01-19 Sat 23:22] |
| 4 | a |  1.4 | Friday    | Blue  |    79 | [2026-08-01 Sat 17:27] |
| 5 | a |  7.5 | Friday    | Blue  |   8+9 | [2020-09-15 Tue 13:07] |
| 4 | b |  8.2 | Thursday  | Red   |    41 | [2040-10-27 Sat 09:12] |
|---+---+------+-----------+-------+-------+------------------------|
| 5 | b |  1.1 | Wednesday | Red   |    62 | [2011-01-29 Sat 15:06] |

#+BEGIN: aggregate :table "unsortedtable" :cols "p;^n Day;^a"
| p | Day       |
|---+-----------|
| 1 | Monday    |
| 1 | Tuesday   |
| 1 | Wednesday |
| 2 | Tuesday   |
| 3 | Monday    |
| 3 | Thursday  |
| 3 | Tuesday   |
| 3 | Wednesday |
| 4 | Friday    |
| 4 | Thursday  |
| 5 | Friday    |
| 5 | Wednesday |
#+END:

* Test sorting numeric expression

#+BEGIN: aggregate :table "unsortedtable" :cols "Day count();^N"
| Day       | count() |
|-----------+---------|
| Tuesday   |       4 |
| Wednesday |       3 |
| Monday    |       2 |
| Thursday  |       2 |
| Friday    |       2 |
#+END:

#+BEGIN: aggregate :table "unsortedtable" :cols "Day vsum(Level);^n"
| Day       | vsum(Level) |
|-----------+-------------|
| Thursday  |          82 |
| Monday    |          90 |
| Friday    |          96 |
| Tuesday   |         168 |
| Wednesday |         211 |
#+END:

* Test sorting hline

#+BEGIN: aggregate :table "unsortedtable" :cols "hline;^N q;^a count()"
| hline | q | count() |
|-------+---+---------|
|     2 | b |       1 |
|     1 | a |       2 |
|     1 | b |       3 |
|     0 | a |       5 |
|     0 | b |       2 |
#+END:

* Test sorting dates-times

#+BEGIN: aggregate :table "unsortedtable" :cols "date;^T count()"
| date                   | count() |
|------------------------+---------|
| [2040-10-27 Sat 09:12] |       1 |
| [2035-12-26 Wed 00:00] |       2 |
| [2033-09-26 Mon 03:55] |       1 |
| [2029-09-25 Tue 13:54] |       1 |
| [2026-08-01 Sat 17:27] |       1 |
| [2024-12-23 Mon 09:01] |       1 |
| [2020-09-15 Tue 13:07] |       1 |
| [2019-11-24 Sun 13:04] |       1 |
| [2015-02-27 Fri 16:11] |       1 |
| [2011-01-29 Sat 15:06] |       1 |
| [2002-01-19 Sat 23:22] |       1 |
| [2001-01-19 Fri 03:49] |       1 |
#+END:

* Test sorting major-minor columns

#+BEGIN: aggregate :table "unsortedtable" :cols "date;^t3 Color;^a2 x;^n1"
| date                   | Color |    x |
|------------------------+-------+------|
| [2011-01-29 Sat 15:06] | Red   |  1.1 |
| [2026-08-01 Sat 17:27] | Blue  |  1.4 |
| [2015-02-27 Fri 16:11] | Blue  |  3.5 |
| [2029-09-25 Tue 13:54] | Red   |  3.5 |
| [2033-09-26 Mon 03:55] | Red   |  3.9 |
| [2035-12-26 Wed 00:00] | Blue  |  5.1 |
| [2001-01-19 Fri 03:49] | Red   |  5.7 |
| [2020-09-15 Tue 13:07] | Blue  |  7.5 |
| [2040-10-27 Sat 09:12] | Red   |  8.2 |
| [2002-01-19 Sat 23:22] | Red   |  9.3 |
| [2035-12-26 Wed 00:00] | Red   |  9.3 |
| [2024-12-23 Mon 09:01] | Red   | 12.3 |
| [2019-11-24 Sun 13:04] | Blue  | 12.8 |
#+END:

* Test sorting push

#+ORGTBL: SEND sortag1 orgtbl-to-aggregated-table :cols "cölØr vsum(vâluε);^N count();^N vmean('ra;han');f3"
| cölØr  | vâluε | ra;han |
|--------+-------+--------|
| Red    |   1.3 |     41 |
| Red    |   3.5 |     35 |
| Yellow |   9.1 |     95 |
| Red    |   2.6 |     84 |
| Blue   |   8.7 |     52 |
| Blue   |   7.0 |     29 |
| Yellow |   5.4 |     17 |
| Blue   |   4.9 |     64 |
| Red    |   3.9 |     51 |
| Yellow |   2.4 |     55 |
| Yellow |   6.6 |     34 |
| Red    |   1.1 |     58 |

#+BEGIN RECEIVE ORGTBL sortag1
| cölØr  | vsum(vâluε) | count() | vmean('ra;han') |
|--------+-------------+---------+-----------------|
| Yellow |        23.5 |       4 |          50.250 |
| Blue   |        20.6 |       3 |          48.333 |
| Red    |        12.4 |       5 |          53.800 |
#+END RECEIVE ORGTBL sortag1

* Test hline output

#+name: withhline
| cölØr  | vâluε | ra;han |
|--------+-------+--------|
| Red    |   1.3 |     41 |
| Red    |   3.5 |     35 |
| Yellow |   9.1 |     95 |
| Red    |   2.6 |     84 |
|--------+-------+--------|
| Blue   |   8.7 |     52 |
| Blue   |   7.0 |     29 |
| Yellow |   5.4 |     17 |
|--------+-------+--------|
| Blue   |   4.9 |     64 |
| Red    |   3.9 |     51 |
| Yellow |   2.4 |     55 |
| Yellow |   6.6 |     34 |
|--------+-------+--------|
| Red    |   1.1 |     58 |
| Yellow |   3.4 |     51 |

Are original hlines given back?
#+BEGIN: aggregate :table "withhline" :cols "cölØr vâluε 'ra;han'" :hline 1
| cölØr  | vâluε | 'ra;han' |
|--------+-------+----------|
| Red    |   1.3 |       41 |
| Red    |   3.5 |       35 |
| Yellow |   9.1 |       95 |
| Red    |   2.6 |       84 |
|--------+-------+----------|
| Blue   |   8.7 |       52 |
| Blue   |   7.0 |       29 |
| Yellow |   5.4 |       17 |
|--------+-------+----------|
| Blue   |   4.9 |       64 |
| Red    |   3.9 |       51 |
| Yellow |   2.4 |       55 |
| Yellow |   6.6 |       34 |
|--------+-------+----------|
| Red    |   1.1 |       58 |
| Yellow |   3.4 |       51 |
#+END:

I do not specify hlines in the output
#+BEGIN: aggregate :table "withhline" :cols "cölØr vâluε 'ra;han'"
| cölØr  | vâluε | 'ra;han' |
|--------+-------+----------|
| Red    |   1.3 |       41 |
| Red    |   3.5 |       35 |
| Yellow |   9.1 |       95 |
| Red    |   2.6 |       84 |
| Blue   |   8.7 |       52 |
| Blue   |   7.0 |       29 |
| Yellow |   5.4 |       17 |
| Blue   |   4.9 |       64 |
| Red    |   3.9 |       51 |
| Yellow |   2.4 |       55 |
| Yellow |   6.6 |       34 |
| Red    |   1.1 |       58 |
| Yellow |   3.4 |       51 |
#+END:

What if I want hline on cölØr?
#+BEGIN: aggregate :table "withhline" :cols "cölØr;^a vâluε 'ra;han'" :hline 1
| cölØr  | vâluε | 'ra;han' |
|--------+-------+----------|
| Blue   |   8.7 |       52 |
| Blue   |   7.0 |       29 |
| Blue   |   4.9 |       64 |
|--------+-------+----------|
| Red    |   1.3 |       41 |
| Red    |   3.5 |       35 |
| Red    |   2.6 |       84 |
| Red    |   3.9 |       51 |
| Red    |   1.1 |       58 |
|--------+-------+----------|
| Yellow |   9.1 |       95 |
| Yellow |   5.4 |       17 |
| Yellow |   2.4 |       55 |
| Yellow |   6.6 |       34 |
| Yellow |   3.4 |       51 |
#+END:

And if I explicitly require hline column?
#+BEGIN: aggregate :table "withhline" :cols "hline;^n cölØr;^a vâluε 'ra;han'"
| hline | cölØr  | vâluε | 'ra;han' |
|-------+--------+-------+----------|
|     0 | Red    |   1.3 |       41 |
|     0 | Red    |   3.5 |       35 |
|     0 | Red    |   2.6 |       84 |
|     0 | Yellow |   9.1 |       95 |
|     1 | Blue   |   8.7 |       52 |
|     1 | Blue   |   7.0 |       29 |
|     1 | Yellow |   5.4 |       17 |
|     2 | Blue   |   4.9 |       64 |
|     2 | Red    |   3.9 |       51 |
|     2 | Yellow |   2.4 |       55 |
|     2 | Yellow |   6.6 |       34 |
|     3 | Red    |   1.1 |       58 |
|     3 | Yellow |   3.4 |       51 |
#+END:

And hline rows as well as column?
#+BEGIN: aggregate :table "withhline" :cols "hline;^N cölØr;^a vâluε 'ra;han'" :hline 1
| hline | cölØr  | vâluε | 'ra;han' |
|-------+--------+-------+----------|
|     3 | Red    |   1.1 |       58 |
|     3 | Yellow |   3.4 |       51 |
|-------+--------+-------+----------|
|     2 | Blue   |   4.9 |       64 |
|     2 | Red    |   3.9 |       51 |
|     2 | Yellow |   2.4 |       55 |
|     2 | Yellow |   6.6 |       34 |
|-------+--------+-------+----------|
|     1 | Blue   |   8.7 |       52 |
|     1 | Blue   |   7.0 |       29 |
|     1 | Yellow |   5.4 |       17 |
|-------+--------+-------+----------|
|     0 | Red    |   1.3 |       41 |
|     0 | Red    |   3.5 |       35 |
|     0 | Red    |   2.6 |       84 |
|     0 | Yellow |   9.1 |       95 |
#+END:

Same with hline & cölØr to separate blocks
#+BEGIN: aggregate :table "withhline" :cols "hline;^N cölØr;^a vâluε 'ra;han'" :hline 2
| hline | cölØr  | vâluε | 'ra;han' |
|-------+--------+-------+----------|
|     3 | Red    |   1.1 |       58 |
|-------+--------+-------+----------|
|     3 | Yellow |   3.4 |       51 |
|-------+--------+-------+----------|
|     2 | Blue   |   4.9 |       64 |
|-------+--------+-------+----------|
|     2 | Red    |   3.9 |       51 |
|-------+--------+-------+----------|
|     2 | Yellow |   2.4 |       55 |
|     2 | Yellow |   6.6 |       34 |
|-------+--------+-------+----------|
|     1 | Blue   |   8.7 |       52 |
|     1 | Blue   |   7.0 |       29 |
|-------+--------+-------+----------|
|     1 | Yellow |   5.4 |       17 |
|-------+--------+-------+----------|
|     0 | Red    |   1.3 |       41 |
|     0 | Red    |   3.5 |       35 |
|     0 | Red    |   2.6 |       84 |
|-------+--------+-------+----------|
|     0 | Yellow |   9.1 |       95 |
#+END:

* Test filter only
#+name: planet
| planet  |   mass kg | dist MKM |
|---------+-----------+----------|
| Sun     | 1.9891e30 |        0 |
| Mercury | 3.3022e23 |       60 |
| Venus   | 4.8685e24 |      100 |
| Earth   | 5.9736e24 |      150 |
| Mars    | 6.4185e23 |      220 |
| Jupiter | 1.8986e27 |      780 |
| Saturn  | 5.6846e26 |     1420 |
| Uranus  | 8.6810e25 |     2870 |
| Neptune | 10.243e25 |     4500 |
| Pluto   |   1.25e22 |     5800 |

Without :cols parameter, we get all columns

#+BEGIN: aggregate :table "planet" :cond (> (string-to-number "dist MKM") 150)
| planet  | "mass kg" | "dist MKM" |
|---------+-----------+------------|
| Mars    | 6.4185e23 |        220 |
| Jupiter | 1.8986e27 |        780 |
| Saturn  | 5.6846e26 |       1420 |
| Uranus  | 8.6810e25 |       2870 |
| Neptune | 10.243e25 |       4500 |
| Pluto   |   1.25e22 |       5800 |
#+END:

What happens without column names in the input?

#+name: planetnh
| planet  |   mass kg | dist MKM |
|---------+-----------+----------|
| Sun     | 1.9891e30 |        0 |
| Mercury | 3.3022e23 |       60 |
| Venus   | 4.8685e24 |      100 |
| Earth   | 5.9736e24 |      150 |
| Mars    | 6.4185e23 |      220 |
| Jupiter | 1.8986e27 |      780 |
| Saturn  | 5.6846e26 |     1420 |
| Uranus  | 8.6810e25 |     2870 |
| Neptune | 10.243e25 |     4500 |
| Pluto   |   1.25e22 |     5800 |

#+BEGIN: aggregate :table "planetnh" :cond (<= (string-to-number "$3") 150)
| planet  | "mass kg" | "dist MKM" |
|---------+-----------+------------|
| Sun     | 1.9891e30 |          0 |
| Mercury | 3.3022e23 |         60 |
| Venus   | 4.8685e24 |        100 |
| Earth   | 5.9736e24 |        150 |
#+END:

* Test custom column names

#+BEGIN: aggregate :table "pulledtable" :cols "pé;^n vsum(xà);'sum_of_xà' vmean(yÿ);'average Ÿ' vmax(zö);'MAX of ZÖ'"
| pé | sum_of_xà |     average Ÿ | MAX of ZÖ |
|----+-----------+---------------+-----------|
|  1 |      20.1 |             4 |         9 |
|  2 |        12 |             5 |         5 |
|  3 |        29 |           5.5 |         9 |
|  4 |     a + b | a / 2 + b / 2 |         8 |
|  5 | a + b + 3 | 5 a + b^2 / 2 |         8 |
#+END:

* Test no collision
There should be no collision between column names and reserved Calc function names.
For instance ~vsum~, which is a Calc function, should be usable as a column name.

#+name: keyword-collision
| vmean | sort | vsum | sum | vmax | aaa |
|-------+------+------+-----+------+-----|
|     2 | 12.3 |   43 |  43 |    1 | 8.2 |
|     8 | 34.4 |   81 |  81 |    1 | 9.3 |
|     4 | 51.5 |   40 |  40 |    1 | 1.3 |
|     5 |  8.1 |   27 |  27 |    2 | 3.9 |
|     2 |  4.7 |   41 |  41 |    2 | 3.5 |
|     9 | 33.9 |   62 |  62 |    3 | 2.1 |
|     1 | 41.7 |   83 |  83 |    3 | 2.7 |

#+BEGIN: aggregate :table "keyword-collision" :cols "vmax count() vsum(vmean) vsum(sort) sort(vsum) sort(sum) vmean(sum);%.2f vmean(vsum);f2"
| vmax | count() | vsum(vmean) | vsum(sort) | sort(vsum)   | sort(sum)    | vmean(sum) | vmean(vsum) |
|------+---------+-------------+------------+--------------+--------------+------------+-------------|
|    1 |       3 |          14 |       98.2 | [40, 43, 81] | [40, 43, 81] |      54.67 |       54.67 |
|    2 |       2 |           7 |       12.8 | [27, 41]     | [27, 41]     |      34.00 |          34 |
|    3 |       2 |          10 |       75.6 | [62, 83]     | [62, 83]     |      72.50 |       72.50 |
#+END:

* Test disordered formatters & decorators

#+BEGIN: aggregate :table "planet" :cols "planet vmax('mass kg');^n;e4;'MassKG' vmin('dist MKM')*1e6;^N;'DistKM';e2"
| planet  |   MassKG | DistKM |
|---------+----------+--------|
| Pluto   |  12.5e21 |  5.8e9 |
| Mercury | 330.2e21 |   60e6 |
| Mars    | 641.9e21 |  220e6 |
| Venus   | 4.869e24 |  100e6 |
| Earth   | 5.974e24 |  150e6 |
| Uranus  | 86.81e24 |  2.9e9 |
| Neptune | 102.4e24 |  4.5e9 |
| Saturn  | 568.5e24 |  1.4e9 |
| Jupiter | 1.899e27 |  780e6 |
| Sun     | 1.989e30 |    0e0 |
#+END:

* Test lambda post-processing

#+BEGIN: aggregate :table "pulledtable" :cols "qû vsum(zö)" :post (lambda (table) (append table '(hline (c 112233))))
| qû | vsum(zö) |
|----+----------|
| b  |       38 |
| a  |       29 |
|----+----------|
| c  |   112233 |
#+END:

#+BEGIN: aggregate :table "pulledtable" :cols "qû vsum(zö)" :post (lambda (table) (append '((c 112233) hline) table))
| c  |   112233 |
|----+----------|
| qû | vsum(zö) |
|----+----------|
| b  |       38 |
| a  |       29 |
#+END:

* Test babel post-processing

#+BEGIN: aggregate :table "pulledtable" :cols "qû vsum(zö)" :post "post-proc-babel(*this*)"
| AA |     BB |
|----+--------|
| c  | 112233 |
|----+--------|
| b  |     38 |
| a  |     29 |
#+END:

#+name: post-proc-babel
#+begin_src elisp :var intbl="" :colnames '(AA BB)
(append
 '((c 112233) hline)
 intbl))
#+end_src

* Test push lambda post-processing

#+ORGTBL: SEND sent-aggregate-post orgtbl-to-aggregated-table :cols "a vsum(b) vsum(c)" :post (lambda (tbl) (append tbl '(hline (h 9 "8"))))
#+ORGTBL: SEND sent-transpose-post orgtbl-to-transposed-table :cols "a c"               :post (lambda (tbl) (append tbl '(hline (h "" 3.4 "8.8"))))
| a |  b |  c |
|---+----+----|
| x | 34 | 56 |
| i | 90 | 12 |
| x | 51 |  3 |
| i |  1 | 11 |

#+BEGIN RECEIVE ORGTBL sent-aggregate-post
| a | vsum(b) | vsum(c) |
|---+---------+---------|
| x |      85 |      59 |
| i |      91 |      23 |
|---+---------+---------|
| h |       9 |       8 |
#+END RECEIVE ORGTBL sent-aggregate-post

#+BEGIN RECEIVE ORGTBL sent-transpose-post
| a |   |   x |   i | x |  i |
| c |   |  56 |  12 | 3 | 11 |
|---+---+-----+-----+---+----|
| h |   | 3.4 | 8.8 |
#+END RECEIVE ORGTBL sent-transpose-post

* Test push babel post-processing

#+ORGTBL: SEND sent-transpose-post-babel orgtbl-to-transposed-table :cols "p r q"             :post "post-proc-babel-send(*this*)"
#+ORGTBL: SEND sent-aggregate-post-babel orgtbl-to-aggregated-table :cols "p vsum(q) vsum(r)" :post "post-proc-babel-send(intbl=*this*)"
|     q | p |     r |
|-------+---+-------|
|  34.9 | x |  56.1 |
|  9.20 | i |  77.2 |
| 51.29 | x |  3.86 |
|  76.7 | i | 19.47 |

#+BEGIN RECEIVE ORGTBL sent-aggregate-post-babel
| x   |  86.19 | 59.96 |
| i   |   85.9 | 96.67 |
| add | 3.1416 |   5.6 |
|-----+--------+-------|
| sub |  2.718 | -42.0 |
#+END RECEIVE ORGTBL sent-aggregate-post-babel

#+BEGIN RECEIVE ORGTBL sent-transpose-post-babel
| p   |        |     x |    i |     x |     i |
| r   |        |  56.1 | 77.2 |  3.86 | 19.47 |
| q   |        |  34.9 | 9.20 | 51.29 |  76.7 |
| add | 3.1416 |   5.6 |
|-----+--------+-------+------+-------+-------|
| sub |  2.718 | -42.0 |
#+END RECEIVE ORGTBL sent-transpose-post-babel

#+name: post-proc-babel-send
#+begin_src elisp :var intbl=""
(append
 intbl
 '((add 3.1416 "5.6") hline (sub 2.718 "-42.0")))
#+end_src

